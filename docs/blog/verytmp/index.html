<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    
    
    
    <title>verytmp</title>

    

    
    
    
    <link rel="canonical" href="https://blinsay.com/blog/verytmp/">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://blinsay.com/blog/verytmp/">

    

    

    
    <link rel="stylesheet" href="https://blinsay.com/style.css" />
    
</head>

<body theme="auto">
    <div class="w">
        <header>
            
            <nav>
                
                <a href="/" >home</a>
                
                <a href="/blog" >posts</a>
                
            </nav>
            
            
<h1>verytmp</h1>
<p class="post-meta"><time datetime="2024-05-06">2024-05-06</time></p>

        </header>
        <main class="page-content" aria-label="Content">
            
<p><a href="https://github.com/blinsay/verytmp"><code>verytmp</code></a> came out of a previous employer's problem with badly behaved programs that weren't cleaning up large temporary files. Inevitably, someone who had to work with that code - and usually not the person who wrote the code! - would fill up their tempdir and spend a few minutes or hours being extremely confused about why other programs were suddenly throwing errors.</p>
<p>Our <a href="https://twitter.com/geofft">local mad scientist</a> realized that this was obviously a problem for linux namespaces, and <code>verytmp</code> was born. By using (abusing?) a private mount namespace, <code>verytmp</code> takes advantage of the fact that <a href="https://unix.stackexchange.com/questions/212172/what-happens-if-the-last-process-in-a-namespace-exits">mount namespaces are garbage collected</a> to give you a fully-functional in-memory filesystem that gets cleaned up when your process exits without relying on <strong>any</strong> userspace code. No more full <code>/tmp</code>, no more strange errors.</p>
<p><a href="https://github.com/blinsay/verytmp">The code is here</a>, and was a lot of fun to write. Because the goal is to create a detached mount namespace, you end up with a filesystem you can't reference with a absolute paths, which means that your API for accessing files and directories has to look a little bit different than the usual interfaces. Instead you end up with something a lot more like <code>openat2</code> and friends, which was both a fun exercise in API design and a fun excuse <a href="https://github.com/nix-rust/nix/pull/2339">to contribute openat2 bindings to the <code>nix</code> crate</a>.</p>


        </main>
        <footer>
            
            
        </footer>
    </div>
</body>

</html>
