<!doctype html><html lang=en><head><meta charset=utf-8><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1" name=viewport><title>verytmp</title><link href=https://blinsay.com/blog/verytmp/ rel=canonical><meta content=website property=og:type><meta content=https://blinsay.com/blog/verytmp/ property=og:url><link href=https://blinsay.com/favicon-16x16.png rel=icon size=16x16 type=image/png><link href=https://blinsay.com/favicon-32x32.png rel=icon size=32x32 type=image/png><link href=https://blinsay.com/style.css rel=stylesheet><body theme=auto><div class=w><header><nav><a href=/>home</a><a href=/blog>posts</a></nav><h1>verytmp</h1><p class=post-meta><time datetime=2024-05-06>2024-05-06</time></header><main aria-label=Content class=page-content><p><a href=https://github.com/blinsay/verytmp><code>verytmp</code></a> came out of a previous employer's problem with badly behaved programs that weren't cleaning up large temporary files. Inevitably, someone who had to work with that code - and usually not the person who wrote the code! - would fill up their tempdir and spend a few minutes or hours being extremely confused about why other programs were suddenly throwing errors.<p>Our <a href=https://twitter.com/geofft>local mad scientist</a> realized that this was obviously a problem for linux namespaces, and <code>verytmp</code> was born. By using (abusing?) a private mount namespace, <code>verytmp</code> takes advantage of the fact that <a href=https://unix.stackexchange.com/questions/212172/what-happens-if-the-last-process-in-a-namespace-exits>mount namespaces are garbage collected</a> to give you a fully-functional in-memory filesystem that gets cleaned up when your process exits without relying on <strong>any</strong> userspace code. No more full <code>/tmp</code>, no more strange errors.<p><a href=https://github.com/blinsay/verytmp>The code is here</a>, and was a lot of fun to write. Because the goal is to create a detached mount namespace, you end up with a filesystem you can't reference with a absolute paths, which means that your API for accessing files and directories has to look a little bit different than the usual interfaces. Instead you end up with something a lot more like <code>openat2</code> and friends, which was both a fun exercise in API design and a fun excuse <a href=https://github.com/nix-rust/nix/pull/2339>to contribute openat2 bindings to the <code>nix</code> crate</a>.</main><footer></footer></div>