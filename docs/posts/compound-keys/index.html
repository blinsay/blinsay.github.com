<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/static/style.css"><link rel="stylesheet" href="/static/highlight.github-gist.min.css"><link rel="icon" size="32x32" type="image/png" href="/static/favicon-32x32.png"><link rel="icon" size="16x16" type="image/png" href="/static/favicon-16x16.png"><script src="/static/highlight.min.js"></script><script>hljs.highlightAll();</script></head><body><div class="w"><header><nav class="top-nav"><a href="/">home</a><a href="/posts">posts</a></nav><h1>Map Keys and Lifetimes</h1><p class="post-meta"><time datetime="2024-11-24">2024-11-24</time></p></header><main aria-label="Content" class="page-content"><hr />
<p><strong>UPDATE:</strong> Less than 30 minutes after posting this, <a href="https://bsky.app/profile/did:plc:jlnnta4zi2luwhy44wb4v3hh">Andrew Werner</a>
came along with a really nice answer. It's now included as the bottom of the
post so you can walk through a few ways to almost solve this problem before
hitting an actual answer.</p>
<hr />
<p>I ran into a weird complexity cliff with Rust's <code>HashMap</code> and lifetimes
the other day. It's enough of a head scratcher that I thought I'd write it
up and see if anyone on the broader internet knew what was going on.</p>
<p>The rest of this post assumes you're comfortable enough with Rust to
see some moderately complicated lifetimes and understand what's going on.
You don't need a perfect mental model of the borrow checker.</p>
<hr />
<p><code>HashMap</code> and <code>BTreeMap</code> are pretty darn good and I use them a lot. Suppose
you're me and you're <a href="https://junctionlabs.io">making some HTTP requests</a> and
you want to track some request stats by host and port. It's pretty easy and
boring to do that with a <code>HashMap</code>.</p>
<pre><code class="language-rust">use std::collections::HashMap;

fn main() {
    let bender = Host { hostname: "bender".to_string(), port: 666 };

    let mut host_stats = HashMap::new();
    host_stats.insert(
        bender.clone(),
        Stats { sent: 30, errors: 30 },
    );
    assert_eq!(
        host_stats.get(&amp;bender),
        Some(&amp;Stats { sent: 30, errors: 30}),
    );
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct Host {
    hostname: String,
    port: u16,
}

#[derive(Debug, PartialEq)]
struct Stats {
    sent: usize,
    errors: usize,
}
</code></pre>
<p>Now suppose you're me and you're trying to wrap stats up with some other state
or just want to hide it behind a reasonable interface because we live in a
society. I'm not trying to write <code>HashMap&lt;(String, u16), Stats&gt;</code> everywhere,
and I also don't want people to have to see <code>Host</code> to use this code.</p>
<pre><code class="language-rust">struct HostStats {
    stats: HashMap&lt;Host, Stats&gt;,
}

impl HostStats {
    fn get(&amp;self, hostname: &amp;str, port: u16) -&gt; Option&lt;&amp;Stats&gt; {
        self.stats.get(&amp;Host{
            hostname: hostname.to_string(),
            port,
        })
    }

    fn record(&amp;mut self, hostname: String, port: u16, sent: usize, errors: usize) {
        let host = Host {
            hostname,
            port,
        };
        self.stats.insert(host, Stats { sent, errors });
    }
}
</code></pre>
<p>Now, suppose you're me and you're suddenly annoyed that we can't look up host
with just a reference in <code>get</code> - we have to copy the entire string (<code>hostname.to_string()</code>)
to build an owned <code>Host</code> and then immediately take a reference to it to look
up a key.</p>
<p>My first thought here was to define a key-reference type that can be compared
to <code>Host</code> but doesn't own a hostname. <code>HashMap</code> had other ideas. Take a look at
the <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.get">signature of <code>get</code></a>;
it allows you to do a lookup with any key type <code>Q</code> that can be borrowed as if
it was a <code>K</code>.</p>
<pre><code class="language-rust">pub fn get&lt;Q&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;V&gt;
where
    K: Borrow&lt;Q&gt; + Ord,
    Q: Hash + Eq + ?Sized;
</code></pre>
<p>If you try to do what I tried first, you end up being unable to write a useful
implementation of <code>Borrow</code>. There's no way to return a <code>&amp;HostRef</code> here without
referencing a temporary value AND there is no way to express the appropriate
lifetime constraint without conflicting with the signature of the <code>Borrow</code>
trait.</p>
<pre><code class="language-rust">struct HostRef&lt;'a&gt; {
    hostname: &amp;'a str,
    port: u16,
}


impl std::borrow::Borrow&lt;HostRef&gt; for Host {
    fn borrow(&amp;self) -&gt; &amp;HostRef {
        todo!("good luck")
    }
}
</code></pre>
<p>The fundamental problem with that approach is trying to express that <code>hostname</code>
can either be borrowed or owned, and it shouldn't make a difference. If only
<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">there was a way to express that</a>.</p>
<hr />
<p>Having a <code>Cow</code> <em>almost</em> works, man.</p>
<p>When inserting and get a key, things compile. We can use <code>Cow&lt;'static, str&gt;</code>
to express that we're only going to keep owned keys in the HashMap and keep
explicit lifetime annotations from becoming viral.</p>
<p>Howerever, there are some lifetime shenanigans necessary in the signature of
<code>get</code> - we seem to have have to tell the borrow checker that the borrowed
hostname will live at least as long as <code>&amp;self</code> and the output value.
Intuitively that restriction doesn't make much sense to me - <a href="https://bsky.app/profile/blen.blinsay.com">get in touch</a> if it
makes sense to you.</p>
<pre><code class="language-rust">use std::borrow::Cow;
use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct Host&lt;'a&gt; {
    /// this is now a Cow&lt;'a, str&gt; instead of a String.
    hostname: Cow&lt;'a, str&gt;,
    port: u16,
}

#[derive(Debug, PartialEq)]
struct Stats {
    sent: usize,
    errors: usize,
}

struct HostStats {
    /// store keys as Host&lt;'static&gt; so we don't have to let lifetime
    /// annotations go viral.
    stats: HashMap&lt;Host&lt;'static&gt;, Stats&gt;,
}

impl HostStats {
    /// get now needs some lifetimes - we have to tell the compiler that 'b
    /// outlives 'a, otherwise it gets a bit confused about our key types.
    fn get&lt;'a, 'b: 'a&gt;(&amp;'a self, hostname: &amp;'b str, port: u16) -&gt; Option&lt;&amp;'a Stats&gt; {
        let host = Host {
            hostname: Cow::from(hostname),
            port,
        };

        self.stats.get(&amp;host)
    }

    /// when we save data, we're dealing with owned hostnames, so inferred
    /// lifetimes work here.
    fn record(&amp;mut self, hostname: String, port: u16, sent: usize, errors: usize) {
        let host = Host {
            hostname: Cow::from(hostname),
            port,
        };

        self.stats.insert(host, Stats { sent, errors });
    }
}
</code></pre>
<p>When writing the code that inspired this post, I ended up needing something like
<code>try_record</code> - update stats if they were present, but do nothing if that host
was absent.</p>
<p>That extra level of complexity seems to confuse the borrow checker badly enough
that the code doesn't compile any more. I'm not sure exactly why, but trying to
define that method makes rustc so mad that it gives you <code>error[E0521]: borrowed data escapes outside of method</code>.</p>
<pre><code class="language-rust">impl HostStats {
    fn try_record(&amp;mut self, hostname: &amp;str, port: u16, sent: usize, errors: usize) {
        let host = Host {
            hostname: Cow::from(hostname),
            port,
        };

        if let Some(stats) = self.stats.get_mut(&amp;host) {
            stats.sent = sent;
            stats.errors = errors;
        }
    }
}
</code></pre>
<p>If you understand this one, <strong>please</strong> <a href="https://bsky.app/profile/blen.blinsay.com">get in touch</a>. I'm extremely curious! The
code is <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=61597cab54b5fbb373b44ba2cde6c6ee">on the playground</a>
if you'd like to mess with it yourself.</p>
<p>I ended up working through this problem by working around it; the compound key
lookup didn't end up being important to my problem. If it had been, I would
have taken <a href="https://bsky.app/profile/directxman12.dev">Solly's</a> excellent
suggestion to use the <a href="https://docs.rs/hashbrown/0.15.1/hashbrown/index.html">hashbrown</a>
crate directly.</p>
<p><code>hashbrown</code> gives you two ways out of this - <code>get</code> is defined in terms of an
<code>Equivalent</code> trait instead of <code>Borrow</code> and, if you really need it, the
<a href="https://docs.rs/hashbrown/0.15.1/hashbrown/struct.HashMap.html#method.raw_entry_mut">raw entry API</a>
is right there.</p>
<hr />
<p>Less than 30 minutes after posting this, I got some answers!</p>
<p><a href="https://bsky.app/profile/did:plc:jlnnta4zi2luwhy44wb4v3hh">Andrew Werner</a>
came through with an <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8faf0b693bec2f1b1975ec3e74cbac5d">extremely nice way to define key types</a>.
The <code>Borrow</code> trait requires you to be able to return a reference to the borrowed
type, so Andrew split the <code>Host</code> into an inner <code>HostKey</code> and an outer <code>Host</code> so
that the <code>Host</code> can be borrowed as a <code>HostKey</code>.</p>
<pre><code class="language-rust">#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct HostKey&lt;'a&gt; {
    hostname: Cow&lt;'a, str&gt;,
    port: u16,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct Host&lt;'a&gt;(HostKey&lt;'a&gt;);

impl&lt;'a, 'me&gt; Borrow&lt;HostKey&lt;'a&gt;&gt; for Host&lt;'me&gt;
where
    'me: 'a,
{
    fn borrow(&amp;self) -&gt; &amp;HostKey&lt;'a&gt; {
        return &amp;self.0;
    }
}
</code></pre>
<p>The lifetime bounds here are important: you're only allowed to borrow a <code>Host</code>
as a <code>HostKey</code> if the lifetime on the <code>HostKey</code> is shorter than the lifetime
of the <code>Host</code>. I'm not sure if you'd ever want any other bounds here, but
we have to express them explicitly to rustc.</p>
<p>A kind commenter <a href="https://www.reddit.com/r/rust/comments/1gvx51h/comment/ly58i0m/">on Reddit</a>
also pointed out that the weird lifetime error I hit in <code>try_record</code> is probably
a <a href="https://github.com/rust-lang/rust/issues/80389">known issue</a> with <code>get</code> and
<code>get_mut</code>.</p>
</main><footer></footer></div></body></html>