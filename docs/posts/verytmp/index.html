<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/static/style.css"><link rel="stylesheet" href="/static/highlight.github-gist.min.css"><link rel="icon" size="32x32" type="image/png" href="/static/favicon-32x32.png"><link rel="icon" size="16x16" type="image/png" href="/static/favicon-16x16.png"><script src="/static/highlight.min.js"></script><script>hljs.highlightAll();</script></head><body><div class="w"><header><nav class="top-nav"><a href="/">home</a><a href="/posts">posts</a></nav><h1>verytmp</h1><p class="post-meta"><time datetime="2024-05-06">2024-05-06</time></p></header><main aria-label="Content" class="page-content"><p><a href="https://github.com/blinsay/verytmp"><code>verytmp</code></a> came out of a previous employer's problem with badly behaved programs that weren't cleaning up large temporary files. Inevitably, someone who had to work with that code - and usually not the person who wrote the code! - would fill up their tempdir and spend a few minutes or hours being extremely confused about why other programs were suddenly throwing errors.</p>
<p>Our <a href="https://twitter.com/geofft">local mad scientist</a> realized that this was obviously a problem for linux namespaces, and <code>verytmp</code> was born. By using (abusing?) a private mount namespace, <code>verytmp</code> takes advantage of the fact that <a href="https://unix.stackexchange.com/questions/212172/what-happens-if-the-last-process-in-a-namespace-exits">mount namespaces are garbage collected</a> to give you a fully-functional in-memory filesystem that gets cleaned up when your process exits without relying on <strong>any</strong> userspace code. No more full <code>/tmp</code>, no more strange errors.</p>
<p><a href="https://github.com/blinsay/verytmp">The code is here</a>, and was a lot of fun to write. Because the goal is to create a detached mount namespace, you end up with a filesystem you can't reference with a absolute paths, which means that your API for accessing files and directories has to look a little bit different than the usual interfaces. Instead you end up with something a lot more like <code>openat2</code> and friends, which was both a fun exercise in API design and a fun excuse <a href="https://github.com/nix-rust/nix/pull/2339">to contribute openat2 bindings to the <code>nix</code> crate</a>.</p>
</main><footer></footer></div></body></html>